\section{Algorithms and Pseudocodes}

\newcommand{\xdir}{\cbtt{nx}}
\newcommand{\ydir}{\cbtt{ny}}
\newcommand{\zdir}{\cbtt{nz}}
\newcommand{\xydir}{\dbtt{nxy}}
\newcommand{\xyzdir}{\rbtt{nxyz}}
\newcommand{\xmin}{\mbtt{x$_{min}$}}
\newcommand{\ymin}{\mbtt{y$_{min}$}}
\newcommand{\zmin}{\mbtt{z$_{min}$}}
\newcommand{\xmax}{\mbtt{x$_{max}$}}
\newcommand{\ymax}{\mbtt{y$_{max}$}}
\newcommand{\zmax}{\mbtt{z$_{max}$}}

\subsection{Data structures and global variables}
\label{algo-pc-data}

\begin{algorithm}
\begin{algorithmic}
\Procedure{Gobal data structures}


\#define TRUE \un
\#define FALSE \zero

// atom in pixel data structure
typedef struct pixel\_atom pixel\_atom;
struct pixel\_atom
{
  int atom\_id;             // the atom ID
  float coord[\trois];          // the atom coordinates on x, y and z
};

// pixel data structure
typedef struct pixel pixel;
struct pixel
{
  int pid;                 // the pixel number
  int p\_xyz[\trois];            // the pixel coordinates in the grid
  bool tested;             // was the pixel checked already
  int patoms;              // number of atom(s) in pixel
  pixel\_atom * pix\_atoms;  // list of atom(s) in the pixel, to be allocated
  int neighbors;           // number of neighbors for pixel
  int pixel\_neighbors[\mbtt{27}]; // the list of neighbor pixels, maximum 27
};

// pixel grid data structure
typedef struct pixel\_grid pixel\_grid;
struct pixel\_grid
{
  int pixels;              // total number of pixels in the grid
  int n\_pix[\trois];            // number of pixel(s) on each axis
  int n\_xy;                // number of pixels in the plan xy
  pixel * pixel\_list;      // pointer to the pixels, to be allocated
};

// bond distance data structure
typedef struct distance distance;
struct distance
{
  float length;            // the distance in \AA\ squared
  float Rij[\trois];            // vector components of x, y and z
};

/*
  the following are considered to be provided by the user
*/

// model description
int atoms;                 // the total number of atom(s)
float ** c\_coord;          // list of Cartesian coordinates: c\_coord[atoms][3]
float cutoff;              // the cutoff to define atomic bond(s)
float cutoff\_squared;      // squared value for the cutoff

// model box description
float l\_params[\trois];         // lattice a, b and c
float cart\_to\_frac[\trois][\trois];  // Cartesian to fractional coordinates matrix
float frac\_to\_cart[\trois][\trois];  // fractional to Cartesian coordinates matrix
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{Set periodic boundary condition pixel shift}
\label{algo-set-pshift}
\begin{algorithm}
\begin{algorithmic}[1]
{\footnotesize{
\Procedure{pbc\_shift}{\xdir, \ydir, \zdir, \xydir, \xyzdir, pixel[\trois], shift[\trois][\trois][\trois]}
  \State
  \State Input:
  \State  \qquad - \xdir\ is the number of pixels in the x direction
  \State  \qquad - \ydir\ is the number of pixels in the y direction
  \State  \qquad - \zdir\ is the number of pixels in the z direction
  \State  \qquad - \xydir\ = \xdir\ $\times$ \ydir
  \State `\qquad - \xyzdir\ = \xydir\ $\times$ \zdir
  \State  \qquad - pixel[\trois] is the pixel coordinates on x, z and z
  \State
  \State Output:
  \State  \qquad - shift[\trois][\trois][\trois] is the shift due tot PBC
  \State
  \For{\vbtt{x} = \un, $\dots$, \trois}
    \For{\rbtt{y} = \un, $\dots$, \trois}
      \For{\obtt{z} = \un, $\dots$, \trois}
        \State shift[\vbtt{x}][\rbtt{y}][\obtt{z}] = \zero
      \EndFor
    \EndFor
  \EndFor
  \State
  \If{pixel[\un] = \un}
    \For{\rbtt{y} = \un, $\dots$, \trois}
      \For{\obtt{z} = \un, $\dots$, \trois}
        \State shift[\un][\rbtt{y}][\obtt{z}] = \xdir
      \EndFor
    \EndFor
  \ElsIf{pixel[\un] = \xdir}
    \For{\rbtt{y} = \un, $\dots$, \trois}
      \For{\obtt{z} = \un, $\dots$, \trois}
        \State shift[\trois][\rbtt{y}][\obtt{z}] = - \xdir
      \EndFor
    \EndFor
  \EndIf
  \State
  \If{pixel[\deux] = \un}
    \For{\vbtt{x} = \un, $\dots$, \trois}
      \For{\obtt{z} = \un, $\dots$, \trois}
	\State shift[\vbtt{x}][\un][\obtt{z}] += \xydir
      \EndFor
    \EndFor
  \ElsIf{pixel[\deux] = \ydir}
    \For{\vbtt{x} = \un, $\dots$, \trois}
      \For{\obtt{z} = \un, $\dots$, \trois}
        \State shift[\vbtt{x}][\trois][\obtt{z}] -= \xydir
      \EndFor
    \EndFor
  \EndIf
  \State
  \If{pixel\_coord[\trois] = \un}
    \For{\vbtt{x} = \un, $\dots$, \trois}
      \For{\rbtt{y} = \un, $\dots$, \trois}
        \State shift[\vbtt{x}][\rbtt{y}][\un] += \xyzdir
      \EndFor
    \EndFor
  \ElsIf{pixel\_coord[\trois] = \zdir}
    \For{\vbtt{x} = \un, $\dots$, \trois}
      \For{\rbtt{z} = \un, $\dots$, \trois}
        \State shift[\vbtt{x}][\rbtt{y}][\trois] -= \xyzdir
      \EndFor
    \EndFor
  \EndIf
\EndProcedure
}}
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{C code: add atom to pixel}
\label{algo-c-add-atom-pixel}

\begin{algorithm}
\begin{algorithmic}
\Procedure{add\_atom\_to\_pixel}{pixel * the\_pixel, int pixel\_coord[\trois], int atom\_id, float atom\_coord[\trois]}
{
  int \dbtt{axis};
  if (! the\_pixel->patoms) 
  {
    // if the pixel do not contains any atom yet, then save its coordinates in the grid
    for ( \dbtt{axis} = \zero ; \dbtt{axis} < \trois ; \dbtt{axis} ++ )
    {
      the\_pixel->p\_xyz[\dbtt{axis}] = pixel\_coord[\dbtt{axis}];
    }
    // allocate the memory to store the first pixel\_atom information
    the\_pixel->pix\_atoms = malloc(sizeof*the\_pixel->pix\_atoms);
  }
  else
  {
    // otherwise reallocate memory to store the new pixel\_atom information
    the\_pixel->pix\_atoms = realloc(the\_pixel->pix\_atoms, (the\_pixel->patoms+\un)*sizeof*the\_pixel->pix\_atoms);
  }
  the\_pixel->pix\_atoms[the\_pixel->patoms].atom\_id = atom\_id;
  for ( \dbtt{axis} = \zero ; \dbtt{axis} < \trois ; \dbtt{axis} ++ )
  {
    the\_pixel->pix\_atoms[the\_pixel->patoms].coord[\dbtt{axis}] = atom\_coord[\dbtt{axis}];
  }
  // increment the number of atom(s) in the pixel
  the\_pixel->patoms ++;
}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{C code: preparation of the pixel grid}
\label{algo-c-pc-grid}

\begin{algorithm}
\begin{algorithmic}
{\footnotesize{
\Procedure{prepare\_pixel\_grid}{use\_pbc, l\_params[\trois], cutoff, c\_cooord[][\trois]}
  \State
  \State Input:
  \State  \qquad - use\_pbc : flag to set if PBC are used or not
  \State  \qquad - l\_params[\trois] : lattice parameters A, B and C
  \State  \qquad - cutoff : cutoff radius to define first neighbor atoms
  \State
  \State Output:
  \State  \qquad - grid : a pixel grid data structure
  \State

  \If{use\_pbc}
    \For{\dbtt{axis} = \un, $\dots$, \trois}
      \State grid->n\_pix[\dbtt{axis}] = $\lfloor$ (l\_params[\dbtt{axis}] / cutoff) $\rfloor$ + \un
    \EndFor
 Â \Else
    \For{\dbtt{axis} = \un, $\dots$, \trois}
      \State cmin = cmax = c\_coord[\un][\dbtt{axis}]
    \EndFor
    \For{\cbtt{aid} = \deux, $\dots$, atoms}
      \For{\dbtt{axis} = \un, $\dots$, \trois}
	\State cmin = min (cmin, c\_coord[\cbtt{aid}][\dbtt{axis}])
	\State cmax = min (cmax, c\_coord[\cbtt{aid}][\dbtt{axis}])
      \EndFor
    \EndFor
    \For{\dbtt{axis} = \un, $\dots$, \trois}
      \State grid->n\_pix[\dbtt{axis}] = $\lfloor$ (cmax[\dbtt{axis} - cmin[\dbtt{axis}] / cutoff) $\rfloor$ + \un
    \EndFor
  \EndIf
  \State
  \For{\dbtt{axis} = \un, $\dots$, \trois}
    \If{grid->n\_pix[\dbtt{axis}] < \quatre}
      \State grid->n\_pix[\dbtt{axis}] = \un
    \EndIf
  \EndFor
  \State grid->n\_xy = grid->n\_pix[\un] $\times$ grid->n\_pix[\deux]
  \State grid->pixels = grid->n\_xy $\times$ grid->n\_pix[\trois]
  \For{pixel\_num = \un, $\dots$, grid->pixels}
    \State grid->pixel\_list[pixel\_num].pid = pixel\_num
    \State grid->pixel\_list[pixel\_num].patoms = \zero
    \State grid->pixel\_list[pixel\_num].tested = FALSE
  \EndFor
  \State
  \If{use\_pbc}
    \For{\dbtt{aid} = \un, $\dots$, atoms}
      \State f\_coord = matrix\_multiplication (cart\_to\_frac, c\_coord[\cbtt{aid}])
      \For{\dbtt{axis} = \un, $\dots$, \trois}
        \State f\_coord[\dbtt{axis}] -= $\lfloor$ f\_coord[\dbtt{axis}] $\rfloor$
        \State pix[\dbtt{axis}] = $\lfloor$ f\_coord[\dbtt{axis}] $\times$ grid->n\_pix[\dbtt{axis}] $\rfloor$
      \EndFor
      \State pixel\_id = pix[\un] + pix[\deux] $\times$ grid->n\_pix[\un] + pix[\trois] $\times$ grid->n\_xy
      \State add\_atom\_to\_pixel (\& grid->pixel\_list[pixel\_id], \cbtt{aid}, f\_coord)
    \EndFor
  \Else
    \For{\dbtt{aid} = \un, $\dots$, atoms}
      \For{\dbtt{axis} = \un, $\dots$, \trois}
	\State  pix[\dbtt{axis}] = $\lfloor$ (c\_coord[\dbtt{axis}] - cmin[\dbtt{axis}]) / Cutoff $\rfloor$
      \EndFor
      \State pixel\_id = pix[\un] + pix[\deux] $\times$ grid->n\_pix[\un] + pix[\trois] $\times$ grid->n\_xy
      \State add\_atom\_to\_pixel (\& grid->pixel\_list[pixel\_id], \cbtt{aid}, c\_coord)
    \EndFor
  \EndIf
  \Return grid
\EndProcedure
}}
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{C code: finding pixel neighbors}
\label{algo-c-find-pn}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
// finding neighbor pixels for pixel in the grid
// - bool use\_pbc          : flag to set if PBC are used or not
// - pixel\_grid * the\_grid : pointer to the pixel grid
// - pixel * the\_pix       : pointer to the pixel with neighbors to be found
void find\_pixel\_neighbors (bool use\_pbc, pixel\_grid * the\_grid, pixel * the\_pix)
{
  int \dbtt{axis};                       // loop iterator axis id (1=x , 2=y , 3= z)
  int \vbtt{xpos}, \rbtt{ypos}, \obtt{zpos};           // neighbor position on x, y and z
  int l\_start[\trois] = { \zero, \zero, \zero};    // loop iterators starting value
  int l\_end[\trois] = { \trois, \trois, \trois};      // loop iterators ending value
  int pmod[\trois] = {-\un, \zero, \un};       // position modifiers
  int \bftt{nnp};                        // number of neighbors for pixel
  int nid;                        // neighbor id for pixel
  int pbc\_shift[\trois][\trois][\trois];         // shift for pixel neighbor number due to PBC
  bool boundary = FALSE;          // is pixel on the boundary of the grid
  bool keep\_neighbor = TRUE;      // keep or not neighbor during analysis

  if ( use\_pbc )
  {
    set\_pbc\_shift (the\_grid, the\_pix->p\_xyz, pbc\_shift);
  }
  else
  {
    for ( \dbtt{axis} = \zero ; \dbtt{axis} < \trois ; \dbtt{axis} ++ )
    {
      if ( the\_pix->p\_xyz[\dbtt{axis}] == \zero \textbar\textbar the\_pix->p\_xyz[\dbtt{axis}] == the\_grid->n\_pix[\dbtt{axis}] - \un ) boundary = TRUE;
    }
  }
  for ( \dbtt{axis} = \zero ; \dbtt{axis} < \trois ; \dbtt{axis} ++ )
  {
    if ( the\_grid->n\_pix[\dbtt{axis}] == \un )
    {
      l\_start[\dbtt{axis}] = \un;
      l\_end[\dbtt{axis}] = \deux;
    }
  }
  \bftt{nnp} = \zero;
  for ( \vbtt{xpos} = l\_start[\zero] ; \vbtt{xpos} < l\_end[\zero] ; \vbtt{xpos} ++ )
  {
    for ( \rbtt{ypos} = l\_start[\un] ; \rbtt{ypos} < l\_end[\un] ; \rbtt{ypos} ++ )
    {
      for ( \obtt{zpos} = l\_start[\deux] ; \obtt{zpos} < l\_end[\deux] ; \obtt{zpos} ++ )
      {
        keep\_neighbor = TRUE;
        if ( ! use\_pbc \&\& boundary )
        {
          if (( the\_pix->p\_xyz[\zero] == \zero \&\& \vbtt{xpos} == \zero ) \textbar\textbar ( the\_pix->p\_xyz[\zero] == the\_grid->n\_pix[\zero] \&\& \vbtt{xpos} == \deux ))
          {
            keep\_neighbor = FALSE;
          }
          else if (( the\_pix->p\_xyz[\un] == \zero \&\& \rbtt{ypos} == \zero ) \textbar\textbar ( the\_pix->p\_xyz[\un] == the\_grid->n\_pix[\un] \&\& \rbtt{ypos} == \deux ))
          {
            keep\_neighbor = FALSE;
          }
          else if (( the\_pix->p\_xyz[\deux] == \zero \&\& \obtt{zpos} == \zero ) \textbar\textbar ( the\_pix->p\_xyz[\deux] == the\_grid->n\_pix[\deux] \&\& \obtt{zpos} == \deux ))
          {
            keep\_neighbor = FALSE;
          }
        }
        if ( keep\_neighbor )
        {
          nid = the\_pix->pid + pmod[\vbtt{xpos}] + pmod[\rbtt{ypos}] * the\_grid->n\_pix[\zero] + pmod[\obtt{zpos}] * the\_grid->n\_xy;
          if ( use\_pbc ) nid += pbc\_shift[\vbtt{xpos}][\rbtt{ypos}][\obtt{zpos}];
          the\_pix->pixel\_neighbors[\bftt{nnp}] = nid;
          \bftt{nnp} ++ ;
        }
      }
    }
  }
  the\_pix->neighbors = \bftt{nnp};
}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{C code: inter-atomic distance calculation}
\begin{algorithm}
\begin{algorithmic}
\Procedure{}
// evaluating the interatomic distance between 2 pixel atoms
// - bool use\_pbc      : flag to set if PBC are used or not
// - pixel\_atom * at\_i : pointer to first pixel atom
// - pixel\_atom * at\_j : pointer to second pixel atom
distance evaluate\_distance (bool use\_pbc, pixel\_atom * at\_i, pixel\_atom * at\_j)
{
  int \dbtt{axis};          // axis loop iterator
  float u, v;        // float parameters
  distance dist;     // distance data to store calculation results
  for ( \dbtt{axis} = \zero ; \dbtt{axis} < \trois ; \dbtt{axis} ++ )
  {
    dist.Rij[\dbtt{axis}] = at\_i->coord[\dbtt{axis}] - at\_j->coord[\dbtt{axis}];
  }
  if ( use\_pbc )
  {
    // then the pixel\_atom's coordinates are in corrected fractional format
    for ( \dbtt{axis} = \zero ; \dbtt{axis} < \trois ; \dbtt{axis} ++ )
    {
      dist.Rij[\dbtt{axis}] = dist.Rij[\dbtt{axis}] - roundf(dist.Rij[\dbtt{axis}]);
    }
    // transform back to Cartesian coordinates
    // with 'matrix\_multiplication' a user defined function to perform the operation
    dist.Rij = matrix\_multiplication (frac\_to\_cart, dist.Rij);
  }
  dist.length = \zero.\zero;
  for ( \dbtt{axis} = \zero ; \dbtt{axis} < \trois ; \dbtt{axis} ++ )
  {
    dist.length += dist.Rij[\dbtt{axis}] * dist.Rij[\dbtt{axis}];
  }
  // returning the 'distance' data structure that contains:
  // - the squared value for Dij: no time consuming square root calculation !
  // - the components of the distance vector on x, y and z
  return dist;
}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{C code: pixel search for first neighbor atoms}
\label{algo-c-pc-pixel}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
// searching for first neighbor atoms using the grid pixelation/partitioning method
// - bool use\_pbc : flag to set if PBC are used or not
void pixel\_search\_for\_neighbors (bool use\_pbc)
{
  pixel\_grid * all\_pixels;   // pointer to the pixel grid for to analyze
  int \vbtt{pix}, \rbtt{pjx};              // integer pixel ID numbers
  int \dbtt{aid}, \cbtt{bid};              // integer loop atom numbers
  int pid;
  int l\_start, l\_end;         // integer loop modifier
  pixel * pix\_i, * pix\_j;     // pointers on pixel data structure
  pixel\_atom * at\_i, * at\_j;  // pointers on pixel\_atom data structure
  distance Dij;               // distance data structure

  all\_pixels = prepare\_pixel\_grid (use\_pbc);
  // note that the pixel grid 'all\_pixels' must be prepared before the following
  // for all pixels in the grid
  for ( \vbtt{pix} = \zero ; \vbtt{pix} < all\_pixels->pixels ; \vbtt{pix} ++ )
  {
    // setting 'pix\_i' as pointer to pixel number 'pix'
    pix\_i = \& all\_pixels->pixel\_list[\vbtt{pix}];
    // if pixel 'pix\_i' contains atom(s)
    if ( pix\_i->patoms )
    {
      // search for neighbbor pixels of 'pix\_i'
      find\_pixel\_neighbors ( use\_pbc, all\_pixels, pix\_i );
      // testing all 'pix\_i' neighbor pixels
      for ( pid = \zero ; pid < pix\_i->neighbors ; pid ++ )
      {
        \rbtt{pjx} = pix\_i->pixel\_neighbors[pid];
        // setting 'pix\_j' as pointer to pixel number 'pjx'
        pix\_j = \& all\_pixels->pixel\_list[\rbtt{pjx}];
        // checking pixel 'pix\_j' if it:
        // - contains atom(s)
        // - was not tested, otherwise the analysis would have been performed already
        if ( pix\_j->patoms \&\& ! pix\_j->tested )
        {
          // if 'pix\_i' and 'pix\_j' are the same, only test pair of different atoms
          l\_end = (\rbtt{pjx} != \vbtt{pix}) ? \zero : \un;
          // for all atom(s) in 'pix'
          for ( \dbtt{aid} = \zero ; \dbtt{aid} < pix\_i->patoms - l\_end ; \dbtt{aid} ++ )
          {
            // set pointer to the first atom to test
            at\_i = \& pix\_i->pix\_atoms[\dbtt{aid}];
            lstart = (\rbtt{pjx} != \vbtt{pix}) ? \zero : \dbtt{aid} + \un;
            // for all atom(s) in 'pix\_j'
            for ( \cbtt{bid} = l\_start ; \cbtt{bid} < pix\_j->patoms ; \cbtt{bid} ++ )
            {
              // set pointer to the second atom to test
              at\_j = \& pix\_j->pix\_atoms[\cbtt{bid}];
              // evaluate interatomic distance
              Dij = evaluate\_distance (use\_pbc, at\_i, at\_j);
              if ( Dij.length < cutoff\_squared )
              {
                // this is a first neighbor bond !
              }
            }
          }
        }
      }
      // store that pixel 'pix' was tested
      pix\_i->tested = TRUE;
    }
  }
}
\EndProcedure
\end{algorithmic}
\end{algorithm}
