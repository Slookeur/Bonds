\section{Commented Python code}

\subsection{Commented Python code: data structures and global variables}
\label{p-pc-data}

\begin{lstlisting}[language=Python]
# Global data structures and variables used in the next code sections
import numpy as np

# Atom in pixel data structure
class PixelAtom:
  def __init__(self, atom_id=|\zero|, coord=None):
    self.atom_id = atom_id                                           # the atom ID
    self.coord = np.zeros(|\trois|) if coord is None else np.array(coord)   # the atom coordinates on x, y and z

# Pixel data structure
class Pixel:
  def __init__(self, pid=|\zero|, p_co=None, tested=False, patoms=|\zero|, pix_atoms=None, neighbors=|\zero|):
    self.pid = pid                                               # the pixel number
    self.p_co = np.zeros(|\trois|) if p_co is None else np.array(p_co)  # the pixel coordinates in the grid
    self.tested = tested                                         # was the pixel checked already
    self.patoms = patoms                                         # number of atom(s) in pixel
    self.pix_atoms = [] if pix_atoms is None else pix_atoms      # list of atom(s) in the pixel
    self.neighbors = neighbors                                   # number of neighbors for pixel
    self.pixel_neighbors = np.zeros(|\mbtt{27}|, dtype=int)               # the list of neighbor pixels, maximum 27

# Pixel grid data structure
class PixelGrid:
  def __init__(self, pixels=|\zero|, n_pix=None, n_xy=|\zero|, pixel_list=None):
    self.pixels = pixels                                         # total number of pixels in the grid
    self.n_pix = np.zeros(|\trois|, dtype=int) if n_pix is None else np.array(n_pix)   # pixel(s) on each axis
    self.n_xy = n_xy                                             # number of pixels in the plan xy
    self.pixel_list = [] if pixel_list is None else pixel_list   # pointer to the pixels, to be allocated

# Bond distance data structure
class Distance:
  def __init__(self, length=|\zero|.|\zero|, Rij=None):
    self.length = length                                         # the distance in |\AA| squared
    self.Rij = np.zeros(|\trois|) if Rij is None else np.array(Rij)     # vector components of x, y and z

# Model description
atoms = |\zero|                         # the total number of atom(s)
c_coord = None                    # list of Cartesian coordinates: c_coord[atoms][|\trois|]
cutoff = |\zero|.|\zero|                      # the cutoff to define atomic bond(s)
cutoff_squared = |\zero|.|\zero|              # squared value for the cutoff

# Model box description
l_params = np.zeros(|\trois|)            # lattice a, b and c
cart_to_frac = np.zeros((|\trois|, |\trois|))   # Cartesian to fractional coordinates matrix
frac_to_cart = np.zeros((|\trois|, |\trois|))   # fractional to Cartesian coordinates matrix
\end{lstlisting}
\clearpage

\subsection{Commented Python code: set pixel periodic boundary condition shift}

\begin{lstlisting}[language=Python]
# Adjust, if needed, shift to search for pixel neighbor(s) using PBC
# - grid pixel_grid          : the pixel grid
# - int pixel_coord[|\trois|]       : the pixel coordinates in the grid
# - int pbc_shift[|\trois|][|\trois|][|\trois|]   : the shift, correction, to be calculated
def set_pbc_shift(pixel_grid : PixelGrid, pixel_coord : np.ndarray, pbc_shift : np.ndarray):
  # Initialize pbc_shift to zero
  for |\vbtt{x\_pos}| in range(|\trois|):
    for |\rbtt{y\_pos}| in range(|\trois|):
      for |\obtt{z\_pos}| in range(|\trois|):
        pbc_shift[|\vbtt{x\_pos}|][|\rbtt{y\_pos}|][|\obtt{z\_pos}|] = |\zero|        # at first there is no shift

  if pixel_coord[|\zero|] == |\zero|:                         # pixel position on 'x' is min
    for |\rbtt{y\_pos}| in range(|\trois|):
      for |\obtt{z\_pos}| in range(|\trois|):
        pbc_shift[|\zero|][|\rbtt{y\_pos}|][|\obtt{z\_pos}|] = pixel_grid.n_pix[|\zero|]

  elif pixel_coord[|\zero|] == pixel_grid.n_pix[|\zero|] - |\un|: # pixel position on 'x' is max
    for |\rbtt{y\_pos}| in range(|\trois|):
      for |\obtt{z\_pos}| in range(|\trois|):
        pbc_shift[|\deux|][|\rbtt{y\_pos}|][|\obtt{z\_pos}|] = -pixel_grid.n_pix[|\zero|]

  if pixel_coord[|\un|] == |\zero|:                         # pixel position on 'y' is min
    for |\vbtt{x\_pos}| in range(|\trois|):
      for |\obtt{z\_pos}| in range(|\trois|):
        pbc_shift[|\vbtt{x\_pos}|][|\zero|][|\obtt{z\_pos}|] += pixel_grid.n_xy

  elif pixel_coord[|\un|] == pixel_grid.n_pix[|\un|] - |\un|: # pixel position on 'y' is max
    for |\vbtt{x\_pos}| in range(|\trois|):
      for |\obtt{z\_pos}| in range(|\trois|):
        pbc_shift[|\vbtt{x\_pos}|][|\deux|][|\obtt{z\_pos}|] -= pixel_grid.n_xy

  if pixel_coord[|\deux|] == |\zero|:                         # pixel position on 'z' is min
    for |\vbtt{x\_pos}| in range(|\trois|):
      for |\rbtt{y\_pos}| in range(|\trois|):
        pbc_shift[|\vbtt{x\_pos}|][|\rbtt{y\_pos}|][|\zero|] += pixel_grid.pixels

  elif pixel_coord[|\deux|] == pixel_grid.n_pix[|\deux|] - |\un|: # pixel position on 'z' is max
    for |\vbtt{x\_pos}| in range(|\trois|):
      for |\rbtt{y\_pos}| in range(|\trois|):
        pbc_shift[|\vbtt{x\_pos}|][|\rbtt{y\_pos}|][|\deux|] -= pixel_grid.pixels
\end{lstlisting}
\clearpage

\subsection{Commented Python code: finding pixel neighbors}

\begin{lstlisting}[language=Python]
# Finding neighbor pixels for pixel in the grid
# - bool use_pbc : flag to set if PBC are used or not
# - grid * the_grid : pointer to the pixel grid
# - pixel * the_pix : pointer to the pixel with neighbors to be found
def find_pixel_neighbors(use_pbc : bool, the_grid : PixelGrid, the_pix : Pixel):
  boundary = False                            # is pixel on the boundary of the grid
  keep_neighbor = True                        # keep or not neighbor during analysis
  l_start = [|\zero|, |\zero|, |\zero|]                         # loop iterators starting value
  l_end = [|\trois|, |\trois|, |\trois|]                           # loop iterators ending value
  pmod = [-|\un|, |\zero|, |\un|]                           # position modifiers
  pbc_shift = np.zeros((|\trois|, |\trois|, |\trois|), dtype=int)  # shift for pixel neighbor number due to PBC

  # Check if PBC are used
  if use_pbc:
    set_pbc_shift(the_grid, the_pix.p_co, pbc_shift)
  else:
    for |\dbtt{axis}| in range(|\trois|):
      if the_pix.p_co[|\dbtt{axis}|] == |\zero| or the_pix.p_co[|\dbtt{axis}|] == the_grid.n_pix[|\dbtt{axis}|] - |\un|:
        boundary = True

  # Adjust the loop start and end based on the grid dimensions
  for |\dbtt{axis}| in range(|\trois|):
    if the_grid.n_pix[|\dbtt{axis}|] == |\un|:
      l_start[|\dbtt{axis}|] = |\un|
      l_end[|\dbtt{axis}|] = |\deux|

  |\bftt{nnp}| = |\zero|  # number of neighbors
  for |\vbtt{xpos}| in range(l_start[|\zero|], l_end[|\zero|]):
    for |\rbtt{ypos}| in range(l_start[|\un|], l_end[|\un|]):
      for |\obtt{zpos}| in range(l_start[|\deux|], l_end[|\deux|]):
        keep_neighbor = True

        if not use_pbc and boundary:
          if the_pix.p_co[|\zero|] == |\zero| and |\vbtt{xpos}| == |\zero|:
            keep_neighbor = False
          elif the_pix.p_co[|\zero|] == the_grid.n_pix[|\zero|] and |\vbtt{xpos}| == |\deux|:
            keep_neighbor = False
          elif the_pix.p_co[|\un|] == |\zero| and |\rbtt{ypos}| == |\zero|:
            keep_neighbor = False
          elif the_pix.p_co[|\un|] == the_grid.n_pix[|\un|] and |\rbtt{ypos}| == |\deux|:
            keep_neighbor = False
          elif the_pix.p_co[|\deux|] == |\zero| and |\obtt{zpos}| == |\zero|:
            keep_neighbor = False
          elif the_pix.p_co[|\deux|] == the_grid.n_pix[|\deux|] and |\obtt{zpos}| == |\deux|:
            keep_neighbor = False

        if keep_neighbor:
          # Calculate the neighbor id
          nid = the_pix.pid + pmod[|\vbtt{xpos}|] + pmod[|\rbtt{ypos}|] * the_grid.n_pix[|\zero|] + pmod[|\obtt{zpos}|] * the_grid.n_xy
          if use_pbc:
            nid += pbc_shift[|\vbtt{xpos}|][|\rbtt{ypos}|][|\obtt{zpos}|]
          the_pix.neighbor_list[|\bftt{nnp}|] = nid
          |\bftt{nnp}| += |\un|

  the_pix.neighbors = |\bftt{nnp}|
\end{lstlisting}
\clearpage

\subsection{Commented Python code: preparation of the pixel grid}

\begin{lstlisting}[language=Python]
# Preparation of the pixel grid
# - bool use_pbc : flag to set if PBC are used or not
def prepare_pixel_grid(use_pbc : bool):
  grid = PixelGrid()                                 # Create a new pixel grid
  cmin = [float(|\textquotesingle|inf|\textquotesingle|)] * |\trois|                          # Initialize to infinity
  cmax = [-float(|\textquotesingle|inf|\textquotesingle|)] * |\trois|                         # Initialize to negative infinity
  pixel_pos = np.zeros(3, dtype=int)
# User defined function to allocate the memory to store the pixel grid data
  grid = allocate_grid_data()
  
  if not use_pbc:                                    # Without periodic boundary conditions
    for |\dbtt{axis}| in range(|\trois|):
      cmin[|\dbtt{axis}|] = cmax[|\dbtt{axis}|] = c_coord[|\zero|][|\dbtt{axis}|]
    for |\cbtt{aid}| in range(|\un|, atoms):                      # For all atoms
      for |\dbtt{axis}| in range(|\trois|):                          # For x, y and z
        cmin[|\dbtt{axis}|] = min(cmin[|\dbtt{axis}|], c_coord[|\cbtt{aid}|][|\dbtt{axis}|])
        cmax[|\dbtt{axis}|] = max(cmax[|\dbtt{axis}|], c_coord[|\cbtt{aid}|][|\dbtt{axis}|])
    for |\dbtt{axis}| in range(|\trois|):                            # For x, y and z
      grid.n_pix[|\dbtt{axis}|] = int((cmax[|\dbtt{axis}|] - cmin[|\dbtt{axis}|]) / cutoff) + |\un|  # Number of pixels on axis 'axis'
  else:                                              # Using periodic boundary conditions
    for |\dbtt{axis}| in range(|\trois|):                            # For x, y and z
      grid.n_pix[|\dbtt{axis}|] = int(l_params[|\dbtt{axis}|] / cutoff) + |\un|  # Number of pixels on axis 'axis'
  
  for |\dbtt{axis}| in range(|\trois|):                              # For x, y and z
    # Correction if the number of pixels on '|\dbtt{axis}|' is too small
    grid.n_pix[|\dbtt{axis}|] = |\un| if grid.n_pix][|\dbtt{axis}|] < 4 else grid.n_pix[|\dbtt{axis}|]
  
  grid.n_xy = grid.p_pix[|\zero|] * grid.n_pix[|\un|] # Number of pixels on the plan 'xy'
  grid.pixels = grid.n_xy * grid.p_pix[|\deux|]  # Total number of pixels in the grid
  
  # User defined function to allocate the memory to store the pixel information for the grid
  grid.pixel_list = allocate_pixel_data(grid.pixels)
  
  if not use_pbc:                                    # Without periodic boundary conditions
    for |\cbtt{aid}| in range(atoms):                         # For all atoms
      for |\dbtt{axis}| in range(|\trois|):                          # For x, y and z
        pixel_pos[|\dbtt{axis}|] = int((c_coord[|\cbtt{aid}|][|\dbtt{axis}|] - cmin[|\dbtt{axis}|]) / cutoff)
      pixel_num = pixel_pos[|\zero|] + pixel_pos[|\un|] * grid.n_pix[|\zero|] + pixel_pos[|\deux|] * grid.n_xy + |\un|
      # User defined function to:
      # - Add atom 'aid' with coordinates 'c_coord[aid]' to pixel 'pixel_number'
      # - Increment the number of atom(s) in pixel 'pixel_number'
      # - If needed (for the first atom) set pixel coordinates in the grid to 'pixel_pos'
      add_atom_to_pixel(grid, pixel_num, pixel_pos, |\cbtt{aid}|, c_coord[|\cbtt{aid}|])
  else:  # Using periodic boundary conditions
    for |\cbtt{aid}| in range(atoms):                         # For all atoms
      # with 'matrix_multiplication' a user defined function to perform the operation
      f_coord = matrix_multiplication(cart_to_frac, c_coord[|\cbtt{aid}|])
      for |\dbtt{axis}| in range(|\trois|):                          # For x, y and z
        f_coord[|\dbtt{axis}|] = f_coord[|\dbtt{axis}|] - np.floor(f_coord[|\dbtt{axis}|])
        pixel_pos[|\dbtt{axis}|] = int(f_coord[|\dbtt{axis}|] * grid.n_pix[|\dbtt{axis}|])
      pixel_num = pixel_pos[|\zero|] + pixel_pos[|\un|] * grid.n_pix[|\zero|] + pixel_pos[|\deux|] * grid.n_xy + |\un|
      add_atom_to_pixel(grid, pixel_num, pixel_pos, |\cbtt{aid}|, f_coord)  # User defined function (see above)
  
  return grid
\end{lstlisting}
\clearpage

\subsection{Commented Python code: inter-atomic distance calculation}

\begin{lstlisting}[language=Python]
# Evaluating the interatomic distance between |\deux| pixel atoms
# - bool use_pbc : flag to set if PBC are used or not
# - pixel_atom * at_i : pointer to first pixel atom
# - pixel_atom * at_j : pointer to second pixel atom
def evaluate_distance(use_pbc : bool, at_i : PixelAtom, at_j : PixelAtom):
  dist = Distance()         # Placeholder for the distance data structure
  Rij = np.zeros(|\trois|)  # Initialize the distance vector
  # Calculating the distance components between atoms
  for |\dbtt{axis}| in range(|\trois|):
    Rij[|\dbtt{axis}|] = at_i.coord[|\dbtt{axis}|] - at_j.coord[|\dbtt{axis}|]

  if use_pbc:
    # Pixel atom's coordinates are in corrected fractional format
    for |\dbtt{axis}| in range(|\trois|):
      # Absolute value in float format
      u = abs(Rij[|\dbtt{axis}|])
      v = min(u, |\un|.|\zero| - u)
      # Proper value, with proper sign
      Rij[|\dbtt{axis}|] = (Rij[|\dbtt{axis}|] / u) * v
    
    # Transform back to Cartesian coordinates
    # matrix_multiplication is assumed to be defined elsewhere
    Rij = matrix_multiplication(frac_to_cart, Rij)

  # Calculating the squared distance (no square root for efficiency)
  dist.length = np.sum(Rij ** |\deux|)
  dist.Rij = Rij  # Store the distance vector components

  # Returning the 'distance' data structure that contains:
  # - the squared value for Dij
  # - the components of the distance vector on x, y, and z
  return dist
\end{lstlisting}
\clearpage

\subsection{Commented Python code: pixel search for first neighbor atoms}
\label{p-pc-pixel}

\begin{lstlisting}[language=Python]
def pixel_search_for_neighbors(use_pbc : bool):
  # Pointer to the pixel grid for analysis
  all_pixels = prepare_pixel_grid(use_pbc)
  
  # For all pixels in the grid
  for |\vbtt{pix}| in range(all_pixels.pixels):
    # Setting pix_i as pointer to pixel number pix
    pix_i = all_pixels.pixel_list[|\vbtt{pix}|]
    
    # If pixel pix_i contains atom(s)
    if pix_i.patoms:
      # Search for neighbor pixels
      find_pixel_neighbors(use_pbc, all_pixels, pix_i)
      
      # Testing all pix_i neighbor pixels
      for pid in range(pix_i.neighbors):
        |\rbtt{pjx}| = pix_i.pixel_neighbors[pid]
        # Setting pix_j as pointer to pixel number pjx
        pix_j = all_pixels.pixel_list[|\rbtt{pjx}|]
        
        # Checking pixel pix_j if it:
        # - contains atom(s)
        # - was not tested, otherwise the analysis would have been performed already
        if pix_j.patoms and not pix_j.tested:
          # If pix_i and pix_j are the same, only test pair of different atoms
          end = |\zero| if |\rbtt{pjx}| != |\vbtt{pix}| else |\un|
          
          # For all atom(s) in pix_i
          for |\dbtt{aid}| in range(pix_i.patoms - end):
            # Set pointer to the first atom to test
            at_i = pix_i.pix_atoms[|\dbtt{aid}|]
            start = |\zero| if |\rbtt{pjx}| != |\vbtt{pix}| else |\dbtt{aid}| + |\un|
            
            # For all atom(s) in pix_j
            for |\cbtt{bid}| in range(start, pix_j.patoms):
              # Set pointer to the second atom to test
              at_j = pix_j.pix_atoms[|\cbtt{bid}|]
              
              # Evaluate interatomic distance
              Dij = evaluate_distance(use_pbc, at_i, at_j)
              
              if Dij.length < cutoff_squared:
                # This is a bond!
                pass
                
      # Store that pixel pix_i was tested
      pix_i.tested = True
\end{lstlisting}
