\section{Commented Python code}

\subsection{Python code: data structures and global variables}
\label{algo-p-pc-data}

\begin{algorithm}
# Global data structures and variables used in the next code sections
import numpy as np

# atom in pixel data structure
class PixelAtom:
  def \_\_init\_\_(self, atom\_id=\zero, coord=None):
    self.atom\_id = atom\_id                                                    # the atom ID
    self.coord = np.zeros(\trois) if coord is None else np.array(coord)            # the atom coordinates on x, y and z

# pixel data structure
class Pixel:
  def \_\_init\_\_(self, pid=\zero, p\_xyz=None, tested=False, patoms=\zero, pix\_atoms=None, neighbors=\zero):
    self.pid = pid                                                            # the pixel number
    self.p\_xyz = np.zeros(\trois) if p\_xyz is None else np.array(p\_xyz)            # the pixel coordinates in the grid
    self.tested = tested                                                      # was the pixel checked already
    self.patoms = patoms                                                      # number of atom(s) in pixel
    self.pix\_atoms = [] if pix\_atoms is None else pix\_atoms                   # list of atom(s) in the pixel
    self.neighbors = neighbors                                                # number of neighbors for pixel
    self.pixel\_neighbors = np.zeros(\mbtt{27}, dtype=int)                            # the list of neighbor pixels, maximum 27

# pixel grid data structure
class PixelGrid:
  def \_\_init\_\_(self, pixels=\zero, n\_pix=None, n\_xy=\zero, pixel\_list=None):
    self.pixels = pixels                                                      # total number of pixels in the grid
    self.n\_pix = np.zeros(\trois, dtype=int) if n\_pix is None else np.array(n\_pix) # pixel(s) on each axis
    self.n\_xy = n\_xy                                                          # number of pixels in the plan xy
    self.pixel\_list = [] if pixel\_list is None else pixel\_list                # pointer to the pixels, to be allocated

# bond distance data structure
class Distance:
  def \_\_init\_\_(self, length=\zero.\zero, Rij=None):
    self.length = length                                                      # the distance in \AA squared
    self.Rij = np.zeros(\trois) if Rij is None else np.array(Rij)                  # vector components of x, y and z

#
# the following are considered to be provided by the user 
#

# model description
atoms = \zero                                                                     # the total number of atom(s)
c\_coord = None                                                                # list of Cartesian coordinates: c\_coord[atoms][\trois]
cutoff = \zero.\zero                                                                  # the cutoff to define atomic bond(s)
cutoff\_squared = \zero.\zero                                                          # squared value for the cutoff

# model box description
l\_params = np.zeros(\trois)                                                        # lattice a, b and c
cart\_to\_frac = np.zeros((\trois, \trois))                                               # Cartesian to fractional coordinates matrix
frac\_to\_cart = np.zeros((\trois, \trois))                                               # fractional to Cartesian coordinates matrix
\end{algorithm}
\clearpage

\subsection{Python code: set pixel periodic boundary condition shift}

\begin{algorithm}
# adjust, if needed, shift to search for pixel neighbor(s) using PBC
# - grid pixel\_grid          : the pixel grid
# - int pixel\_coord[\trois]       : the pixel coordinates in the grid
# - int pbc\_shift[\trois][\trois][\trois]   : the shift, correction, to be calculated
def set\_pbc\_shift(pixel\_grid : PixelGrid, pixel\_coord : np.ndarray, pbc\_shift : np.ndarray):
  # Initialize pbc\_shift to zero
  for \vbtt{x\\_pos} in range(\trois):
    for \rbtt{y\\_pos} in range(\trois):
      for \obtt{z\\_pos} in range(\trois):
        pbc\_shift[\vbtt{x\\_pos}][\rbtt{y\\_pos}][\obtt{z\\_pos}] = \zero        # initialization without any shift

  if pixel\_coord[\zero] == \zero:                         # pixel position on 'x' is min
    for \rbtt{y\\_pos} in range(\trois):
      for \obtt{z\\_pos} in range(\trois):
        pbc\_shift[\zero][\rbtt{y\\_pos}][\obtt{z\\_pos}] = pixel\_grid.n\_pix[\zero]

  elif pixel\_coord[\zero] == pixel\_grid.n\_pix[\zero] - \un: # pixel position on 'x' is max
    for \rbtt{y\\_pos} in range(\trois):
      for \obtt{z\\_pos} in range(\trois):
        pbc\_shift[\deux][\rbtt{y\\_pos}][\obtt{z\\_pos}] = -pixel\_grid.n\_pix[\zero]

  if pixel\_coord[\un] == \zero:                         # pixel position on 'y' is min
    for \vbtt{x\\_pos} in range(\trois):
      for \obtt{z\\_pos} in range(\trois):
        pbc\_shift[\vbtt{x\\_pos}][\zero][\obtt{z\\_pos}] += pixel\_grid.n\_xy

  elif pixel\_coord[\un] == pixel\_grid.n\_pix[\un] - \un: # pixel position on 'y' is max
    for \vbtt{x\\_pos} in range(\trois):
      for \obtt{z\\_pos} in range(\trois):
        pbc\_shift[\vbtt{x\\_pos}][\deux][\obtt{z\\_pos}] -= pixel\_grid.n\_xy

  if pixel\_coord[\deux] == \zero:                         # pixel position on 'z' is min
    for \vbtt{x\\_pos} in range(\trois):
      for \rbtt{y\\_pos} in range(\trois):
        pbc\_shift[\vbtt{x\\_pos}][\rbtt{y\\_pos}][\zero] += pixel\_grid.pixels

  elif pixel\_coord[\deux] == pixel\_grid.n\_pix[\deux] - \un: # pixel position on 'z' is max
    for \vbtt{x\\_pos} in range(\trois):
      for \rbtt{y\\_pos} in range(\trois):
        pbc\_shift[\vbtt{x\\_pos}][\rbtt{y\\_pos}][\deux] -= pixel\_grid.pixels
\end{algorithm}

\clearpage

\subsection{Python code: add atom to pixel}
\label{algo-c-add\_atom\_pixel}
\begin{algorithm}
def add\_atom\_to\_pixel(the\_pixel: Pixel, pixel\_coord: np.ndarray, atom\_id: int, atom\_coord: np.ndarray):
  if not the\_pixel.patoms:
    # if the pixel do not contains any atom yet, then save its coordinates in the grid
    for \dbtt{axis} in range(\trois):
      the\_pixel.p\_xyz[\dbtt{axis}] = pixel\_coord[\dbtt{axis}]
 
  new\_atom = PixelAtom(atom\_id, atom\_coord)
  the\_pixel.pix\_atoms.append(new\_atom)
  
  # increment the number of atom(s) in the pixel
  the\_pixel.patoms += \un

\end{algorithm}

\clearpage

\subsection{Python code: preparation of the pixel grid}

\begin{algorithm}
# preparation of the pixel grid
# - bool use\_pbc : flag to set if PBC are used or not
def prepare\_pixel\_grid(use\_pbc : bool):
  grid = PixelGrid()                                 # create a new pixel grid
  cmin = [float(\textquotesingleinf\textquotesingle)] * \trois                          # initialize to infinity
  cmax = [-float(\textquotesingleinf\textquotesingle)] * \trois                         # initialize to negative infinity
  pixel\_pos = np.zeros(3, dtype=int)
  
  if not use\_pbc:                                    # without periodic boundary conditions
    for \dbtt{axis} in range(\trois):
      cmin[\dbtt{axis}] = cmax[\dbtt{axis}] = c\_coord[\zero][\dbtt{axis}]
    for \cbtt{aid} in range(\un, atoms):                      # for all atoms
      for \dbtt{axis} in range(\trois):                          # for x, y and z
        cmin[\dbtt{axis}] = min(cmin[\dbtt{axis}], c\_coord[\cbtt{aid}][\dbtt{axis}])
        cmax[\dbtt{axis}] = max(cmax[\dbtt{axis}], c\_coord[\cbtt{aid}][\dbtt{axis}])
    for \dbtt{axis} in range(\trois):                            # for x, y and z
      # number of pixels on axis 'axis'
      grid.n\_pix[\dbtt{axis}] = int((cmax[\dbtt{axis}] - cmin[\dbtt{axis}]) / cutoff) + \un
  else:                                              # Using periodic boundary conditions
    for \dbtt{axis} in range(\trois):                            # for x, y and z
      # number of pixels on axis 'axis'
      grid.n\_pix[\dbtt{axis}] = int(l\_params[\dbtt{axis}] / cutoff) + \un
  
  for \dbtt{axis} in range(\trois):                              # for x, y and z
    # correction if the number of pixels on '\dbtt{axis}' is too small
    grid.n\_pix[\dbtt{axis}] = \un if grid.n\_pix[\dbtt{axis}] < 4 else grid.n\_pix[\dbtt{axis}]
  
  grid.n\_xy = grid.n\_pix[\zero] * grid.n\_pix[\un]          # number of pixels on the plan 'xy'
  grid.pixels = grid.n\_xy * grid.n\_pix[\deux]            # total number of pixels in the grid
  
  grid.pixel\_list = [Pixel(pid=i) for i in range(grid.pixels)]

  if not use\_pbc:                                    # without periodic boundary conditions
    for \cbtt{aid} in range(atoms):                         # for all atoms
      for \dbtt{axis} in range(\trois):                          # for x, y and z
        pixel\_pos[\dbtt{axis}] = int((c\_coord[\cbtt{aid}][\dbtt{axis}] - cmin[\dbtt{axis}]) / cutoff)
      pixel\_num = pixel\_pos[\zero] + pixel\_pos[\un] * grid.n\_pix[\zero] + pixel\_pos[\deux] * grid.n\_xy
      add\_atom\_to\_pixel(grid.pixel\_list[pixel\_num], pixel\_pos, \cbtt{aid}, c\_coord[\cbtt{aid}])
  else:                                              # using periodic boundary conditions
    for \cbtt{aid} in range(atoms):                         # for all atoms
      # with 'matrix\_multiplication' a user defined function to perform the operation
      f\_coord = matrix\_multiplication(cart\_to\_frac, c\_coord[\cbtt{aid}])
      for \dbtt{axis} in range(\trois):                          # for x, y and z
        f\_coord[\dbtt{axis}] = f\_coord[\dbtt{axis}] - np.floor(f\_coord[\dbtt{axis}])
        pixel\_pos[\dbtt{axis}] = int(f\_coord[\dbtt{axis}] * grid.n\_pix[\dbtt{axis}])
      pixel\_num = pixel\_pos[\zero] + pixel\_pos[\un] * grid.n\_pix[\zero] + pixel\_pos[\deux] * grid.n\_xy
      add\_atom\_to\_pixel(grid.pixel\_list[pixel\_num], pixel\_pos, \cbtt{aid}, f\_coord)
  
  return grid
\end{algorithm}

\clearpage

\subsection{Python code: finding pixel neighbors}

\begin{algorithm}
# Finding neighbor pixels for pixel in the grid
# - bool use\_pbc    : flag to set if PBC are used or not
# - grid * the\_grid : pointer to the pixel grid
# - pixel * the\_pix : pointer to the pixel with neighbors to be found
def find\_pixel\_neighbors(use\_pbc : bool, the\_grid : PixelGrid, the\_pix : Pixel):
  boundary = False                            # is pixel on the boundary of the grid
  keep\_neighbor = True                        # keep or not neighbor during analysis
  l\_start = [\zero, \zero, \zero]                         # loop iterators starting value
  l\_end = [\trois, \trois, \trois]                           # loop iterators ending value
  pmod = [-\un, \zero, \un]                           # position modifiers
  pbc\_shift = np.zeros((\trois, \trois, \trois), dtype=int)  # shift for pixel neighbor number due to PBC

  # check if PBC are used
  if use\_pbc:
    set\_pbc\_shift(the\_grid, the\_pix.p\_xyz, pbc\_shift)
  else:
    for \dbtt{axis} in range(\trois):
      if the\_pix.p\_xyz[\dbtt{axis}] == \zero or the\_pix.p\_xyz[\dbtt{axis}] == the\_grid.n\_pix[\dbtt{axis}] - \un:
        boundary = True

  # adjust the loop start and end based on the grid dimensions
  for \dbtt{axis} in range(\trois):
    if the\_grid.n\_pix[\dbtt{axis}] == \un:
      l\_start[\dbtt{axis}] = \un
      l\_end[\dbtt{axis}] = \deux

  \bftt{nnp} = \zero  # number of neighbors
  for \vbtt{xpos} in range(l\_start[\zero], l\_end[\zero]):
    for \rbtt{ypos} in range(l\_start[\un], l\_end[\un]):
      for \obtt{zpos} in range(l\_start[\deux], l\_end[\deux]):
        keep\_neighbor = True

        if not use\_pbc and boundary:
          if the\_pix.p\_xyz[\zero] == \zero and \vbtt{xpos} == \zero:
            keep\_neighbor = False
          elif the\_pix.p\_xyz[\zero] == the\_grid.n\_pix[\zero] and \vbtt{xpos} == \deux:
            keep\_neighbor = False
          elif the\_pix.p\_xyz[\un] == \zero and \rbtt{ypos} == \zero:
            keep\_neighbor = False
          elif the\_pix.p\_xyz[\un] == the\_grid.n\_pix[\un] and \rbtt{ypos} == \deux:
            keep\_neighbor = False
          elif the\_pix.p\_xyz[\deux] == \zero and \obtt{zpos} == \zero:
            keep\_neighbor = False
          elif the\_pix.p\_xyz[\deux] == the\_grid.n\_pix[\deux] and \obtt{zpos} == \deux:
            keep\_neighbor = False

        if keep\_neighbor:
          # calculate the neighbor id
          nid = the\_pix.pid + pmod[\vbtt{xpos}] + pmod[\rbtt{ypos}] * the\_grid.n\_pix[\zero] + pmod[\obtt{zpos}] * the\_grid.n\_xy
          if use\_pbc:
            nid += pbc\_shift[\vbtt{xpos}][\rbtt{ypos}][\obtt{zpos}]
          the\_pix.pixel\_neighbors[\bftt{nnp}] = nid
          \bftt{nnp} += \un

  the\_pix.neighbors = \bftt{nnp}
\end{algorithm}

\clearpage

\subsection{Python code: inter-atomic distance calculation}

\begin{algorithm}
# evaluating the interatomic distance between 2 pixel atoms
# - bool use\_pbc      : flag to set if PBC are used or not
# - pixel\_atom * at\_i : pointer to first pixel atom
# - pixel\_atom * at\_j : pointer to second pixel atom
def evaluate\_distance(use\_pbc : bool, at\_i : PixelAtom, at\_j : PixelAtom):
  dist = Distance()   # placeholder for the distance data structure
  Rij = np.zeros(\trois)  # initialize the distance vector
  # calculating the distance components between atoms
  for \dbtt{axis} in range(\trois):
    Rij[\dbtt{axis}] = at\_i.coord[\dbtt{axis}] - at\_j.coord[\dbtt{axis}]

  if use\_pbc:
    # then the pixel\_atom's coordinates are in corrected fractional format
    for \dbtt{axis} in range(\trois):
      Rij[axis] = Rij[axis] - round(Rij[axis])
    
    # transform back to Cartesian coordinates
    # matrix\_multiplication is assumed to be defined elsewhere
    Rij = matrix\_multiplication(frac\_to\_cart, Rij)

  # calculating the squared distance (no square root for efficiency)
  dist.length = np.sum(Rij ** \deux)
  dist.Rij = Rij  # store the distance vector components

  # returning the 'distance' data structure that contains:
  # - the squared value for Dij
  # - the components of the distance vector on x, y, and z
  return dist
\end{algorithm}

\clearpage

\subsection{Python code: pixel search for first neighbor atoms}
\label{algo-p-pc-pixel}

\begin{algorithm}
def pixel\_search\_for\_neighbors(use\_pbc : bool):
  # pointer to the pixel grid for analysis
  all\_pixels = prepare\_pixel\_grid(use\_pbc)
  
  # for all pixels in the grid
  for \vbtt{pix} in range(all\_pixels.pixels):
    # setting pix\_i as pointer to pixel number pix
    pix\_i = all\_pixels.pixel\_list[\vbtt{pix}]
    
    # if pixel pix\_i contains atom(s)
    if pix\_i.patoms:
      # search for neighbor pixels
      find\_pixel\_neighbors(use\_pbc, all\_pixels, pix\_i)
      
      # testing all pix\_i neighbor pixels
      for pid in range(pix\_i.neighbors):
        \rbtt{pjx} = pix\_i.pixel\_neighbors[pid]
        # Setting pix\_j as pointer to pixel number pjx
        pix\_j = all\_pixels.pixel\_list[\rbtt{pjx}]
        
        # checking pixel pix\_j if it:
        # - contains atom(s)
        # - was not tested, otherwise the analysis would have been performed already
        if pix\_j.patoms and not pix\_j.tested:
          # If pix\_i and pix\_j are the same, only test pair of different atoms
          end = \zero if \rbtt{pjx} != \vbtt{pix} else \un
          
          # for all atom(s) in pix\_i
          for \dbtt{aid} in range(pix\_i.patoms - end):
            # Set pointer to the first atom to test
            at\_i = pix\_i.pix\_atoms[\dbtt{aid}]
            start = \zero if \rbtt{pjx} != \vbtt{pix} else \dbtt{aid} + \un
            
            # for all atom(s) in pix\_j
            for \cbtt{bid} in range(start, pix\_j.patoms):
              # Set pointer to the second atom to test
              at\_j = pix\_j.pix\_atoms[\cbtt{bid}]
              
              # evaluate interatomic distance
              Dij = evaluate\_distance(use\_pbc, at\_i, at\_j)
              
              if Dij.length < cutoff\_squared:
                # This is a bond!
                pass
                
      # store that pixel pix\_i was tested
      pix\_i.tested = True
\end{algorithm}
