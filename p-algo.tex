\section{Commented Python code}

\subsection{Python code: data structures and global variables}
\label{algo-p-pc-data}

\begin{algorithm}
# Global data structures and variables used in the next code sections
import numpy as np

# atom in pixel data structure
class PixelAtom:
  def __init__(self, atom_id=\zero, coord=None):
    self.atom_id = atom_id                                                    # the atom ID
    self.coord = np.zeros(\trois) if coord is None else np.array(coord)            # the atom coordinates on x, y and z

# pixel data structure
class Pixel:
  def __init__(self, pid=\zero, p_xyz=None, tested=False, patoms=\zero, pix_atoms=None, neighbors=\zero):
    self.pid = pid                                                            # the pixel number
    self.p_xyz = np.zeros(\trois) if p_xyz is None else np.array(p_xyz)            # the pixel coordinates in the grid
    self.tested = tested                                                      # was the pixel checked already
    self.patoms = patoms                                                      # number of atom(s) in pixel
    self.pix_atoms = [] if pix_atoms is None else pix_atoms                   # list of atom(s) in the pixel
    self.neighbors = neighbors                                                # number of neighbors for pixel
    self.pixel_neighbors = np.zeros(\mbtt{27}, dtype=int)                            # the list of neighbor pixels, maximum 27

# pixel grid data structure
class PixelGrid:
  def __init__(self, pixels=\zero, n_pix=None, n_xy=\zero, pixel_list=None):
    self.pixels = pixels                                                      # total number of pixels in the grid
    self.n_pix = np.zeros(\trois, dtype=int) if n_pix is None else np.array(n_pix) # pixel(s) on each axis
    self.n_xy = n_xy                                                          # number of pixels in the plan xy
    self.pixel_list = [] if pixel_list is None else pixel_list                # pointer to the pixels, to be allocated

# bond distance data structure
class Distance:
  def __init__(self, length=\zero.\zero, Rij=None):
    self.length = length                                                      # the distance in \AA squared
    self.Rij = np.zeros(\trois) if Rij is None else np.array(Rij)                  # vector components of x, y and z

#
# the following are considered to be provided by the user 
#

# model description
atoms = \zero                                                                     # the total number of atom(s)
c_coord = None                                                                # list of Cartesian coordinates: c_coord[atoms][\trois]
cutoff = \zero.\zero                                                                  # the cutoff to define atomic bond(s)
cutoff_squared = \zero.\zero                                                          # squared value for the cutoff

# model box description
l_params = np.zeros(\trois)                                                        # lattice a, b and c
cart_to_frac = np.zeros((\trois, \trois))                                               # Cartesian to fractional coordinates matrix
frac_to_cart = np.zeros((\trois, \trois))                                               # fractional to Cartesian coordinates matrix
\end{algorithm}
\clearpage

\subsection{Python code: set pixel periodic boundary condition shift}

\begin{algorithm}
# adjust, if needed, shift to search for pixel neighbor(s) using PBC
# - grid pixel_grid          : the pixel grid
# - int pixel_coord[\trois]       : the pixel coordinates in the grid
# - int pbc_shift[\trois][\trois][\trois]   : the shift, correction, to be calculated
def set_pbc_shift(pixel_grid : PixelGrid, pixel_coord : np.ndarray, pbc_shift : np.ndarray):
  # Initialize pbc_shift to zero
  for \vbtt{x\_pos} in range(\trois):
    for \rbtt{y\_pos} in range(\trois):
      for \obtt{z\_pos} in range(\trois):
        pbc_shift[\vbtt{x\_pos}][\rbtt{y\_pos}][\obtt{z\_pos}] = \zero        # initialization without any shift

  if pixel_coord[\zero] == \zero:                         # pixel position on 'x' is min
    for \rbtt{y\_pos} in range(\trois):
      for \obtt{z\_pos} in range(\trois):
        pbc_shift[\zero][\rbtt{y\_pos}][\obtt{z\_pos}] = pixel_grid.n_pix[\zero]

  elif pixel_coord[\zero] == pixel_grid.n_pix[\zero] - \un: # pixel position on 'x' is max
    for \rbtt{y\_pos} in range(\trois):
      for \obtt{z\_pos} in range(\trois):
        pbc_shift[\deux][\rbtt{y\_pos}][\obtt{z\_pos}] = -pixel_grid.n_pix[\zero]

  if pixel_coord[\un] == \zero:                         # pixel position on 'y' is min
    for \vbtt{x\_pos} in range(\trois):
      for \obtt{z\_pos} in range(\trois):
        pbc_shift[\vbtt{x\_pos}][\zero][\obtt{z\_pos}] += pixel_grid.n_xy

  elif pixel_coord[\un] == pixel_grid.n_pix[\un] - \un: # pixel position on 'y' is max
    for \vbtt{x\_pos} in range(\trois):
      for \obtt{z\_pos} in range(\trois):
        pbc_shift[\vbtt{x\_pos}][\deux][\obtt{z\_pos}] -= pixel_grid.n_xy

  if pixel_coord[\deux] == \zero:                         # pixel position on 'z' is min
    for \vbtt{x\_pos} in range(\trois):
      for \rbtt{y\_pos} in range(\trois):
        pbc_shift[\vbtt{x\_pos}][\rbtt{y\_pos}][\zero] += pixel_grid.pixels

  elif pixel_coord[\deux] == pixel_grid.n_pix[\deux] - \un: # pixel position on 'z' is max
    for \vbtt{x\_pos} in range(\trois):
      for \rbtt{y\_pos} in range(\trois):
        pbc_shift[\vbtt{x\_pos}][\rbtt{y\_pos}][\deux] -= pixel_grid.pixels
\end{algorithm}

\clearpage

\subsection{Python code: add atom to pixel}
\label{algo-c-add_atom_pixel}
\begin{algorithm}
def add_atom_to_pixel(the_pixel: Pixel, pixel_coord: np.ndarray, atom_id: int, atom_coord: np.ndarray):
  if not the_pixel.patoms:
    # if the pixel do not contains any atom yet, then save its coordinates in the grid
    for \dbtt{axis} in range(\trois):
      the_pixel.p_xyz[\dbtt{axis}] = pixel_coord[\dbtt{axis}]
 
  new_atom = PixelAtom(atom_id, atom_coord)
  the_pixel.pix_atoms.append(new_atom)
  
  # increment the number of atom(s) in the pixel
  the_pixel.patoms += \un

\end{algorithm}

\clearpage

\subsection{Python code: preparation of the pixel grid}

\begin{algorithm}
# preparation of the pixel grid
# - bool use_pbc : flag to set if PBC are used or not
def prepare_pixel_grid(use_pbc : bool):
  grid = PixelGrid()                                 # create a new pixel grid
  cmin = [float(\textquotesingleinf\textquotesingle)] * \trois                          # initialize to infinity
  cmax = [-float(\textquotesingleinf\textquotesingle)] * \trois                         # initialize to negative infinity
  pixel_pos = np.zeros(3, dtype=int)
  
  if not use_pbc:                                    # without periodic boundary conditions
    for \dbtt{axis} in range(\trois):
      cmin[\dbtt{axis}] = cmax[\dbtt{axis}] = c_coord[\zero][\dbtt{axis}]
    for \cbtt{aid} in range(\un, atoms):                      # for all atoms
      for \dbtt{axis} in range(\trois):                          # for x, y and z
        cmin[\dbtt{axis}] = min(cmin[\dbtt{axis}], c_coord[\cbtt{aid}][\dbtt{axis}])
        cmax[\dbtt{axis}] = max(cmax[\dbtt{axis}], c_coord[\cbtt{aid}][\dbtt{axis}])
    for \dbtt{axis} in range(\trois):                            # for x, y and z
      # number of pixels on axis 'axis'
      grid.n_pix[\dbtt{axis}] = int((cmax[\dbtt{axis}] - cmin[\dbtt{axis}]) / cutoff) + \un
  else:                                              # Using periodic boundary conditions
    for \dbtt{axis} in range(\trois):                            # for x, y and z
      # number of pixels on axis 'axis'
      grid.n_pix[\dbtt{axis}] = int(l_params[\dbtt{axis}] / cutoff) + \un
  
  for \dbtt{axis} in range(\trois):                              # for x, y and z
    # correction if the number of pixels on '\dbtt{axis}' is too small
    grid.n_pix[\dbtt{axis}] = \un if grid.n_pix[\dbtt{axis}] < 4 else grid.n_pix[\dbtt{axis}]
  
  grid.n_xy = grid.n_pix[\zero] * grid.n_pix[\un]          # number of pixels on the plan 'xy'
  grid.pixels = grid.n_xy * grid.n_pix[\deux]            # total number of pixels in the grid
  
  grid.pixel_list = [Pixel(pid=i) for i in range(grid.pixels)]

  if not use_pbc:                                    # without periodic boundary conditions
    for \cbtt{aid} in range(atoms):                         # for all atoms
      for \dbtt{axis} in range(\trois):                          # for x, y and z
        pixel_pos[\dbtt{axis}] = int((c_coord[\cbtt{aid}][\dbtt{axis}] - cmin[\dbtt{axis}]) / cutoff)
      pixel_num = pixel_pos[\zero] + pixel_pos[\un] * grid.n_pix[\zero] + pixel_pos[\deux] * grid.n_xy
      add_atom_to_pixel(grid.pixel_list[pixel_num], pixel_pos, \cbtt{aid}, c_coord[\cbtt{aid}])
  else:                                              # using periodic boundary conditions
    for \cbtt{aid} in range(atoms):                         # for all atoms
      # with 'matrix_multiplication' a user defined function to perform the operation
      f_coord = matrix_multiplication(cart_to_frac, c_coord[\cbtt{aid}])
      for \dbtt{axis} in range(\trois):                          # for x, y and z
        f_coord[\dbtt{axis}] = f_coord[\dbtt{axis}] - np.floor(f_coord[\dbtt{axis}])
        pixel_pos[\dbtt{axis}] = int(f_coord[\dbtt{axis}] * grid.n_pix[\dbtt{axis}])
      pixel_num = pixel_pos[\zero] + pixel_pos[\un] * grid.n_pix[\zero] + pixel_pos[\deux] * grid.n_xy
      add_atom_to_pixel(grid.pixel_list[pixel_num], pixel_pos, \cbtt{aid}, f_coord)
  
  return grid
\end{algorithm}

\clearpage

\subsection{Python code: finding pixel neighbors}

\begin{algorithm}
# Finding neighbor pixels for pixel in the grid
# - bool use_pbc    : flag to set if PBC are used or not
# - grid * the_grid : pointer to the pixel grid
# - pixel * the_pix : pointer to the pixel with neighbors to be found
def find_pixel_neighbors(use_pbc : bool, the_grid : PixelGrid, the_pix : Pixel):
  boundary = False                            # is pixel on the boundary of the grid
  keep_neighbor = True                        # keep or not neighbor during analysis
  l_start = [\zero, \zero, \zero]                         # loop iterators starting value
  l_end = [\trois, \trois, \trois]                           # loop iterators ending value
  pmod = [-\un, \zero, \un]                           # position modifiers
  pbc_shift = np.zeros((\trois, \trois, \trois), dtype=int)  # shift for pixel neighbor number due to PBC

  # check if PBC are used
  if use_pbc:
    set_pbc_shift(the_grid, the_pix.p_xyz, pbc_shift)
  else:
    for \dbtt{axis} in range(\trois):
      if the_pix.p_xyz[\dbtt{axis}] == \zero or the_pix.p_xyz[\dbtt{axis}] == the_grid.n_pix[\dbtt{axis}] - \un:
        boundary = True

  # adjust the loop start and end based on the grid dimensions
  for \dbtt{axis} in range(\trois):
    if the_grid.n_pix[\dbtt{axis}] == \un:
      l_start[\dbtt{axis}] = \un
      l_end[\dbtt{axis}] = \deux

  \bftt{nnp} = \zero  # number of neighbors
  for \vbtt{xpos} in range(l_start[\zero], l_end[\zero]):
    for \rbtt{ypos} in range(l_start[\un], l_end[\un]):
      for \obtt{zpos} in range(l_start[\deux], l_end[\deux]):
        keep_neighbor = True

        if not use_pbc and boundary:
          if the_pix.p_xyz[\zero] == \zero and \vbtt{xpos} == \zero:
            keep_neighbor = False
          elif the_pix.p_xyz[\zero] == the_grid.n_pix[\zero] and \vbtt{xpos} == \deux:
            keep_neighbor = False
          elif the_pix.p_xyz[\un] == \zero and \rbtt{ypos} == \zero:
            keep_neighbor = False
          elif the_pix.p_xyz[\un] == the_grid.n_pix[\un] and \rbtt{ypos} == \deux:
            keep_neighbor = False
          elif the_pix.p_xyz[\deux] == \zero and \obtt{zpos} == \zero:
            keep_neighbor = False
          elif the_pix.p_xyz[\deux] == the_grid.n_pix[\deux] and \obtt{zpos} == \deux:
            keep_neighbor = False

        if keep_neighbor:
          # calculate the neighbor id
          nid = the_pix.pid + pmod[\vbtt{xpos}] + pmod[\rbtt{ypos}] * the_grid.n_pix[\zero] + pmod[\obtt{zpos}] * the_grid.n_xy
          if use_pbc:
            nid += pbc_shift[\vbtt{xpos}][\rbtt{ypos}][\obtt{zpos}]
          the_pix.pixel_neighbors[\bftt{nnp}] = nid
          \bftt{nnp} += \un

  the_pix.neighbors = \bftt{nnp}
\end{algorithm}

\clearpage

\subsection{Python code: inter-atomic distance calculation}

\begin{algorithm}
# evaluating the interatomic distance between 2 pixel atoms
# - bool use_pbc      : flag to set if PBC are used or not
# - pixel_atom * at_i : pointer to first pixel atom
# - pixel_atom * at_j : pointer to second pixel atom
def evaluate_distance(use_pbc : bool, at_i : PixelAtom, at_j : PixelAtom):
  dist = Distance()   # placeholder for the distance data structure
  Rij = np.zeros(\trois)  # initialize the distance vector
  # calculating the distance components between atoms
  for \dbtt{axis} in range(\trois):
    Rij[\dbtt{axis}] = at_i.coord[\dbtt{axis}] - at_j.coord[\dbtt{axis}]

  if use_pbc:
    # then the pixel_atom's coordinates are in corrected fractional format
    for \dbtt{axis} in range(\trois):
      Rij[axis] = Rij[axis] - round(Rij[axis])
    
    # transform back to Cartesian coordinates
    # matrix_multiplication is assumed to be defined elsewhere
    Rij = matrix_multiplication(frac_to_cart, Rij)

  # calculating the squared distance (no square root for efficiency)
  dist.length = np.sum(Rij ** \deux)
  dist.Rij = Rij  # store the distance vector components

  # returning the 'distance' data structure that contains:
  # - the squared value for Dij
  # - the components of the distance vector on x, y, and z
  return dist
\end{algorithm}

\clearpage

\subsection{Python code: pixel search for first neighbor atoms}
\label{algo-p-pc-pixel}

\begin{algorithm}
def pixel_search_for_neighbors(use_pbc : bool):
  # pointer to the pixel grid for analysis
  all_pixels = prepare_pixel_grid(use_pbc)
  
  # for all pixels in the grid
  for \vbtt{pix} in range(all_pixels.pixels):
    # setting pix_i as pointer to pixel number pix
    pix_i = all_pixels.pixel_list[\vbtt{pix}]
    
    # if pixel pix_i contains atom(s)
    if pix_i.patoms:
      # search for neighbor pixels
      find_pixel_neighbors(use_pbc, all_pixels, pix_i)
      
      # testing all pix_i neighbor pixels
      for pid in range(pix_i.neighbors):
        \rbtt{pjx} = pix_i.pixel_neighbors[pid]
        # Setting pix_j as pointer to pixel number pjx
        pix_j = all_pixels.pixel_list[\rbtt{pjx}]
        
        # checking pixel pix_j if it:
        # - contains atom(s)
        # - was not tested, otherwise the analysis would have been performed already
        if pix_j.patoms and not pix_j.tested:
          # If pix_i and pix_j are the same, only test pair of different atoms
          end = \zero if \rbtt{pjx} != \vbtt{pix} else \un
          
          # for all atom(s) in pix_i
          for \dbtt{aid} in range(pix_i.patoms - end):
            # Set pointer to the first atom to test
            at_i = pix_i.pix_atoms[\dbtt{aid}]
            start = \zero if \rbtt{pjx} != \vbtt{pix} else \dbtt{aid} + \un
            
            # for all atom(s) in pix_j
            for \cbtt{bid} in range(start, pix_j.patoms):
              # Set pointer to the second atom to test
              at_j = pix_j.pix_atoms[\cbtt{bid}]
              
              # evaluate interatomic distance
              Dij = evaluate_distance(use_pbc, at_i, at_j)
              
              if Dij.length < cutoff_squared:
                # This is a bond!
                pass
                
      # store that pixel pix_i was tested
      pix_i.tested = True
\end{algorithm}
