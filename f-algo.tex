\clearpage

\section{Commented FORTRAN90 code}

\subsection{FORTRAN90 code: data structures and global variables}
\label{algo-f-pc-data}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
! global data structures and variables used in the next code sections
MODULE parameters
  
  ! atom in pixel data structure
  TYPE pixel\_atom
    INTEGER                                         :: atom\_id            ! the atom ID
    REAL, DIMENSION(\trois)                              :: coord              ! the atom coordinates on x, y and z
  END TYPE pixel\_atom
  
  ! pixel data structure
  TYPE pixel
    INTEGER                                         :: pid                ! the pixel number
    INTEGER, DIMENSION(\trois)                           :: p\_xyz              ! the pixel coordinates in the grid
    LOGICAL                                         :: tested             ! was the pixel checked already
    INTEGER                                         :: patoms             ! number of atom(s) in pixel
    TYPE(pixel\_atom), DIMENSION(:), ALLOCATABLE     :: pix\_atoms          ! list of atom(s) in pixel, to be allocated
    INTEGER                                         :: neighbors          ! number of neighbors for pixel
    INTEGER, DIMENSION(\mbtt{27})                          :: pixel\_neighbors    ! the list of neighbor pixels, maximum 27
  END TYPE pixel
  
  ! pixel grid data structure
  TYPE pixel\_grid
    INTEGER                                         :: pixels             ! total number of pixels in the grid
    INTEGER, DIMENSION(\trois)                           :: n\_pix              ! number of pixel(s) on each axis
    INTEGER                                         :: n\_xy               ! number of pixels in the plan xy
    TYPE (pixel), DIMENSION(:), ALLOCATABLE, TARGET :: pixel\_list         ! pointer to the pixels, to be allocated
  END TYPE pixel\_grid
  
  ! distance data structure
  TYPE distance
    REAL                                            :: length             ! the distance in \AA\ squared
    REAL, DIMENSION(\trois)                              :: Rij                ! vector components of x, y and z
  END TYPE distance
  
  !
  ! the following are considered to be provided by the user
  !

  ! model description
  INTEGER                                           :: atoms              ! the total number of atom(s)
  REAL, DIMENSION(atoms,\trois)                          :: c\_coord            ! list of Cartesian coordinates
  REAL                                              :: cutoff             ! the cutoff to define first neighbors
  REAL                                              :: cutoff\_squared     ! squared value of the cutoff to define first neighbors
  
  ! model box description
  REAL, DIMENSION(\trois)                                :: l\_params           ! lattice a, b and c
  REAL, DIMENSION(\trois,\trois)                              :: cart\_to\_frac       ! Cartesian to fractional coordinates matrix
  REAL, DIMENSION(\trois,\trois)                              :: frac\_to\_cart       ! fractional to Cartesian coordinates matrix

END MODULE parameters
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{FORTRAN90 code: set pixel periodic boundary condition shift}
\label{algo-f-set-pshift}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
SUBROUTINE set\_pbc\_shift (grid, pixel\_coord, pbc\_shift)
  
  USE parameters
  IMPLICIT NONE
  
  TYPE (pixel\_grid), INTENT(IN)            :: grid                ! the pixel grid
  INTEGER, DIMENSION(\trois), INTENT(IN)        :: pixel\_coord         ! the pixel coordinates in the grid
  INTEGER, DIMENSION(\trois,\trois,\trois), INTENT(INOUT) :: pbc\_shift           ! the shift, correction, to be calculated
  
  pbc\_shift(:,:,:) = \zero                                            ! initialization without any shift

  if ( pixel\_coord(\un) .eq. \un ) then                               ! pixel position on 'x' is min
    pbc\_shift(\un,:,:) = grid%n\_pix(\un)
  else if ( pixel\_coord(\un) .eq. grid%n\_pix(\un) ) then              ! pixel position on 'x' is max
    pbc\_shift(\trois,:,:) = - grid%n\_pix(\un)
  endif
  
  if ( pixel\_coord(\deux) .eq. \un ) then                               ! pixel position on 'y' is min
    pbc\_shift(:,\un,:) = pbc\_shift(:,\un,:) + grid%n\_xy
  else if ( pixel\_coord(\deux) .eq. grid%n\_pix(\deux) ) then              ! pixel position on 'y' is max
    pbc\_shift(:,\trois,:) = pbc\_shift(:,\trois,:) - grid%n\_xy
  endif
  
  if ( pixel\_coord(\trois) .eq. \un ) then                               ! pixel position on 'z' is min
    pbc\_shift(:,:,\un) = pbc\_shift(:,:,\un) + grid%pixels
  else if ( pixel\_coord(\trois) .eq. grid%n\_pix(\trois) ) then              ! pixel position on 'z' is max
    pbc\_shift(:,:,\trois) = pbc\_shift(:,:,\trois) - grid%pixels
  endif
  
END SUBROUTINE set\_pbc\_shift
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{FORTRAN90 code: add atom to pixel}
\label{algo-c-add-atom-pixel}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
SUBROUTINE add\_atom\_to\_pixel (the\_pixel, pixel\_coord, atom\_id, atom\_coord)

  USE parameters
  IMPLICIT NONE

  TYPE (pixel), INTENT(INOUT) :: the\_pixel          ! pointer to the pixel
  INTEGER, DIMENSION(\trois), INTENT(IN) :: pixel\_coord  ! the pixel coordinates in the grid
  INTEGER, INTENT(IN)                :: atom\_id     ! the atom ID number
  INTEGER                            :: \dbtt{axis}        ! loop iterator axis id (1=x, 2=y, 3=z)
  REAL, DIMENSION(\trois), INTENT(IN)     :: atom\_coord  ! the atomic coordinates

  if (the\_pixel%patoms .eq. \zero) then
    ! if the pixel do not contains any atom yet, then save its coordinates in the grid
    do \dbtt{axis} = \un , \trois
      the\_pixel%p\_xyz(\dbtt{axis}) = pixel\_coord(\dbtt{axis})
    enddo
     ! allocate the memory to store the first pixel\_atom information
    allocate(the\_pixel%pix\_atoms(1))
  else
    ! otherwise reallocate memory to store the new pixel\_atom informatio
    the\_pixel%pix\_atoms = realloc(the\_pixel%pix\_atoms, the\_pixel%patoms+1)
  endif
  ! increment the number of atom(s) in the pixel
  the\_pixel%patoms = the\_pixel%patoms + \un
  the\_pixel%pix\_atoms(the\_pixel%patoms)%atom\_id = atom\_id
  do \dbtt{axis} = \un , \trois
    the\_pixel%pix\_atoms(the\_pixel%patoms)%coord(\dbtt{axis}) = atom\_coord(\dbtt{axis})
  enddo

END SUBROUTINE
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{FORTRAN90 code: preparation of the pixel grid}
\label{algo-f-pc-grid}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
! preparation of the pixel grid
SUBROUTINE prepare\_pixel\_grid (use\_pbc, grid)
  
  USE parameters
  IMPLICIT NONE
  
  LOGICAL, INTENT(IN)              :: use\_pbc          ! flag to set if PBC are used or not
  TYPE (pixel\_grid), INTENT(INOUT) :: grid             ! the pixel grid to prepare
  INTEGER                          :: \dbtt{axis}             ! loop iterator axis id (1=x, 2=y, 3=z)
  INTEGER                          :: \cbtt{aid}              ! loop iterator atom number (1, atoms)
  INTEGER                          :: pixel\_num        ! pixel number in the grid
  INTEGER, DIMENSION(\trois)            :: pixel\_pos        ! pixel coordinates in the grid
  REAL, DIMENSION(\trois)               :: cmin, cmax       ! real precision coordinates min, max
  REAL, DIMENSION(\trois)               :: f\_coord          ! real precision fractional coordinates
  
  if ( .not. use\_pbc ) then                            ! without periodic boundary conditions
    do \dbtt{axis} = \un , \trois
      cmin(\dbtt{axis}) = c\_coord(\un,\dbtt{axis})
      cmax(\dbtt{axis}) = c\_coord(\un,\dbtt{axis})
    enddo
    do \cbtt{aid} = \deux , atoms                                 ! for all atoms
      do \dbtt{axis} = \un , \trois                                  ! for x, y and z
        cmin(\dbtt{axis}) = min(cmin(\dbtt{axis}), c\_coord(\cbtt{aid},\dbtt{axis}))
        cmax(\dbtt{axis}) = max(cmax(\dbtt{axis}), c\_coord(\cbtt{aid},\dbtt{axis}))
      enddo
    enddo
    do \dbtt{axis} = \un , \trois                                    ! for x, y and z
      ! number of pixel(s) on \dbtt{axis} '\dbtt{axis}'
      grid%n\_pix(\dbtt{axis}) = INT((cmax(\dbtt{axis}) - cmin(\dbtt{axis})) / cutoff) + \un
    enddo
  else                                                 ! using periodic boundary conditions
    do \dbtt{axis} = \un , \trois                                    ! for x, y and z
      ! number of pixel(s) on \dbtt{axis} '\dbtt{axis}'
      grid%n\_pix(\dbtt{axis}) = INT(l\_params(\dbtt{axis}) / cutoff) + \un
    enddo
  endif
  do \dbtt{axis} = \un , \trois                                      ! for x, y and z
    ! correction if the number of pixel(s) on '\dbtt{axis}' is too small
    if ( grid%n\_pix(\dbtt{axis}) .lt. 4 ) then
      grid%n\_pix(\dbtt{axis}) = \un
    endif
  enddo
  
  grid%n\_xy = grid%n\_pix(\un) * grid%n\_pix(\deux)            ! number of pixels on the plan 'xy'
  grid%pixels = grid%n\_xy * grid%n\_pix(\trois)              ! total number of pixels in the grid

  allocate (grid%pixel\_list(grid%pixels))
  do pixel\_num = 1 , grid%pixels
    grid%pixel\_list(pixel\_num)%pid = pixel\_num
    grid%pixel\_list(pixel\_num)%patoms = 0
    grid%pixel\_list(pixel\_num)%tested = .false.
  enddo
  if ( .not. use\_pbc ) then                            ! without periodic boundary conditions
    do \cbtt{aid} = \un , atoms                                 ! for all atoms
      do \dbtt{axis} = \un , \trois                                  ! for x, y and z
        pixel\_pos(\dbtt{axis}) = INT( (c\_coord(\cbtt{aid},\dbtt{axis}) - cmin(\dbtt{axis}) )/ cutoff)
      enddo
      pixel\_num = pixel\_pos(\un) + pixel\_pos(\deux) * grid%n\_pix(\un) + pixel\_pos(\trois) * grid%n\_xy + \un
      call add\_atom\_to\_pixel (grid%pixel\_list(pixel\_num), pixel\_pos, \cbtt{aid}, c\_coord(\cbtt{aid},:))
    enddo
  else                                                 ! using periodic boundary conditions
    do \cbtt{aid} = \un , atoms                                 ! for all atoms
     f\_coord = MATMUL ( c\_coord(\cbtt{aid}), cart\_to\_frac )
     do \dbtt{axis} = \un , \trois                                   ! for x, y and z
       f\_coord(\dbtt{axis}) = f\_coord(\dbtt{axis}) - floor(f\_coord(\dbtt{axis}))
       pixel\_pos(\dbtt{axis}) = INT(f\_coord(\dbtt{axis}) * grid%n\_pix(\dbtt{axis}))
     enddo
     pixel\_num = pixel\_pos(\un) + pixel\_pos(\deux) * grid%n\_pix(\un) + pixel\_pos(\trois) * grid%n\_xy + \un
     call add\_atom\_to\_pixel (grid%pixel\_list(pixel\_num), pixel\_pos, \cbtt{aid}, f\_coord)
    enddo
  endif

END SUBROUTINE prepare\_pixel\_grid
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{FORTRAN90 code: finding pixel neighbors}
\label{algo-f-find-pn}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
SUBROUTINE find\_pixel\_neighbors (use\_pbc, the\_grid, the\_pix)
  
  USE parameters
  IMPLICIT NONE
  
  LOGICAL, INTENT(IN)                  :: use\_pbc                 ! flag to set if PBC are used or not
  TYPE (pixel\_grid), INTENT(INOUT)     :: the\_grid                ! pointer to the pixel grid
  TYPE (pixel), POINTER, INTENT(INOUT) :: the\_pix                 ! pointer to the pixel
  INTEGER                              :: \dbtt{axis}                    ! loop iterator axis id (1=x, 2=y, 3=z)
  INTEGER                              :: \vbtt{xpos}, \rbtt{ypos}, \obtt{zpos}        ! neighbor position on x, y and z
  INTEGER, DIMENSION(\trois)                :: l\_start = (\un, \un, \un)    ! loop iterators starting value
  INTEGER, DIMENSION(\trois)                :: l\_end = (\trois, \trois, \trois)      ! loop iterators ending value
  INTEGER, DIMENSION(\trois)                :: pmod = (\-\un, \zero, \un)      ! position modifiers
  INTEGER                              :: \bftt{nnp}                     ! number of neighbors for pixel
  INTEGER                              :: nid                     ! neighbor id for pixel
  INTEGER, DIMENSION(\trois,\trois,\trois)            :: pbc\_shift               ! shift, correction, due to PBC
  LOGICAL                              :: boundary=.false.        ! is pixel on the boundary of the grid
  LOGICAL                              :: keep\_neighbor = .true.  ! keep or not neighbor during analysis
  
  if ( use\_pbc ) then
    call set\_pbc\_shift (the\_grid, the\_pix%p\_xyz, pbc\_shift)
  else
    do \dbtt{axis} = \un , \trois
      if ( the\_pix%p\_xyz(\dbtt{axis}) .eq. \un .or. the\_pix%p\_xyz(\dbtt{axis}) .eq. the\_grid%n\_pix(\dbtt{axis}) ) then
        boundary = .true.
      endif
    enddo
  endif
  do \dbtt{axis} = \un , \trois
    if ( the\_grid%n\_pix(\dbtt{axis}) .eq. \un ) then
      l\_start(\dbtt{axis}) = \deux
      l\_end(\dbtt{axis}) = \deux
    endif
  enddo
  \bftt{nnp} = \zero
  do \vbtt{xpos} = l\_start(\un) , l\_end(\un)
    do \rbtt{ypos} = l\_start(\deux) , l\_end(\deux)
      do \obtt{zpos} = l\_start(\trois) , l\_end(\trois)
        keep\_neighbor = .true.
        if ( .not. use\_pbc .and. boundary ) then
          if ( the\_pix%p\_xyz(\un) .eq. \un .and. \vbtt{xpos} .eq. \un ) then
            keep\_neighbor = .false.
          else if ( the\_pix%p\_xyz(\un) .eq. the\_grid%n\_pix(\un) .and. \vbtt{xpos} .eq. \trois ) then
            keep\_neighbor = .false.
          else if ( the\_pix%p\_xyz(\deux) .eq. \un .and. \rbtt{ypos} .eq. \un ) then
            keep\_neighbor = .false.
          else if ( the\_pix%p\_xyz(\deux) .eq. the\_grid%n\_pix(\deux) .and. \rbtt{ypos} .eq. \trois ) then
            keep\_neighbor = .false.
          else if ( the\_pix%p\_xyz(\trois) .eq. \un .and. \obtt{zpos} .eq. \un ) then
            keep\_neighbor = .false.
          else if ( the\_pix%p\_xyz(\trois) .eq. the\_grid%n\_pix(\trois) .and. \obtt{zpos} .eq. \trois ) then
            keep\_neighbor = .false.
          endif
        endif
        if ( keep\_neighbor ) then
          ! evaluating neighbor pixel number in the grid
          nid = the\_pix%pid + pmod(\vbtt{xpos}) + pmod(\rbtt{ypos}) * the\_grid%n\_pix(\un) + pmod(\obtt{zpos}) * the\_grid%n\_xy
          if ( use\_pbc ) then
            ! correcting the value if PBC are used
            nid = nid + pbc\_shift(\vbtt{xpos}, \rbtt{ypos}, \obtt{zpos})
          endif
          the\_pix%pixel\_neighbors(\bftt{nnp}) = nid
          \bftt{nnp} = \bftt{nnp} + \un
        endif
      enddo
    enddo
  enddo
  the\_pix%neighbors = \bftt{nnp}
  
END SUBROUTINE find\_pixel\_neighbors
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{FORTRAN90 code: inter-atomic distance calculation}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
! evaluating the interatomic distance between 2 pixel atoms
SUBROUTINE evaluate\_distance (use\_pbc, at\_i, at\_j, dist)
  
  USE parameters
  IMPLICIT NONE
  
  LOGICAL, INTENT(IN)                    :: use\_pbc   ! flag to set if PBC are used or not
  TYPE (pixel\_atom), POINTER, INTENT(IN) :: at\_i      ! first pixel atom
  TYPE (pixel\_atom), POINTER, INTENT(IN) :: at\_j      ! second pixel atom
  TYPE (distance), INTENT(INOUT)         :: dist      ! calculation results
  INTEGER                                :: \dbtt{axis}      ! loop iterator axis id (1=x, 2=y, 3=z)
  
  do \dbtt{axis} = \un , \trois
    dist%Rij(\dbtt{axis}) = at\_i%coord(\dbtt{axis}) - at\_j%coord(\dbtt{axis})
  enddo
  if ( use\_pbc ) then
    ! then the pixel\_atom's coordinates are in corrected fractional format
    do \dbtt{axis} = \un , \trois
      dist%Rij(\dbtt{axis}) = dist%Rij(\dbtt{axis}) - AnINT(dist%Rij(\dbtt{axis}))
    enddo
    ! transform back to Cartesian coordinates
    dist%Rij = MATMUL( dist%Rij, frac\_to\_cart )
  endif
  
  dist%length = \zero.\zero
  do \dbtt{axis} = \un , \trois
    dist%length = dist%length + dist%Rij(\dbtt{axis}) * dist%Rij(\dbtt{axis})
  enddo
  ! returning the 'distance' data structure that contains:
  ! - the squared value for Dij: no time consuming square root calculation !
  ! - the components of the distance vector on x, y and z
END SUBROUTINE evaluate\_distance
\EndProcedure
\end{algorithmic}
\end{algorithm}

\clearpage

\subsection{FORTRAN90 code: pixel search for first neighbor atoms}
\label{algo-f-pc-pixel}

\begin{algorithm}
\begin{algorithmic}
\Procedure{}
SUBROUTINE pixel\_search\_for\_neighbors (use\_pbc)

  USE parameters
  IMPLICIT NONE

  LOGICAL, INTENT(IN)   :: use\_pbc                      ! flag to set if PBC are used or not
  TYPE (pixel\_grid)     :: all\_pixels                   ! the pixel grid to analyze
  INTEGER               :: \vbtt{pix}, \rbtt{pjx}                     ! integer pixel ID numbers
  INTEGER               :: \dbtt{aid}, \cbtt{bid}                     ! integer loop atom numbers
  INTEGER               :: l\_start, l\_end               ! integer loop modifier
  INTEGER               :: pid
  TYPE (pixel\_atom), POINTER :: pix\_i, pix\_j            ! pointers on pixel data structure
  TYPE (atom), POINTER  :: at\_i, at\_j                   ! pointers on pixel\_atom data structure
  TYPE (distance)       :: Dij                          ! distance data structure
  
  call prepare\_pixel\_grid (use\_pbc, all\_pixels)
  ! note that the pixel grid 'all\_pixels' must be prepared before the following
  ! for all pixels in the grid
  do \vbtt{pix} = \un , all\_pixels%pixels
    ! setting 'pix\_i' as pointer to pixel number 'pix'
    pix\_i => all\_pixels%pixel\_list(\vbtt{pix})
    ! if pixel 'pix\_i' contains atom(s)
    if ( pix\_i%patoms .gt. \zero ) then

      ! search for pixel neighbbors of 'pix\_'
      call find\_pixel\_neighbors (use\_pbc, all\_pixels, pix\_i)

      ! testing all 'pix\_i' neighbor pixels
      do pid = \un , pix\_i%neighbors
        \rbtt{pjx} = pix\_i%pixel\_neighbors(pid)
        ! setting 'pix\_j' as pointer to pixel number 'pjx'
        pix\_j => all\_pixels%pixel\_list(\rbtt{pjx})
        ! checking pixel 'pix\_j' if it:
        ! - contains atom(s)
        ! - was not tested, otherwise the analysis would have been performed already
        if ( pix\_j%patoms .gt. \zero .and. .not. pix\_j%tested ) then
          ! If 'pix\_i' and 'pix\_j' are the same, only test pair of different atoms
          if ( \rbtt{pjx} .eq. \vbtt{pix} ) then
            l\_end = \un
          else
            l\_end = \zero
          endif
          ! for all atom(s) in 'pix\_i'
          do \dbtt{aid} = \un , pix\_i%patoms - l\_end
            ! set pointers to the first atom to test
            at\_i => pix\_i%pix\_atoms(\dbtt{aid})
            if ( \rbtt{pjx} .eq. \vbtt{pix} ) then
              l\_start = \dbtt{aid} + \un
            else
              l\_start = \un
            endif
            ! for all atom(s) in 'pix\_j'
            do \cbtt{bid} = l\_start , pix\_j%patoms
              ! set pointers to the second atom to test
              at\_j => pix\_j%pix\_atoms(\cbtt{bid})
              ! evaluate interatomic distance
              call evaluate\_distance (use\_pbc, at\_i, at\_j, Dij)
              if ( Dij%length .lt. cutoff\_squared ) then
                ! this is a first neighbor bond !
              endif
            enddo
          enddo
        endif
      enddo
      ! store that pixel 'pix\_i' was tested
      pix\_i%tested = .true.
    endif
  enddo
  
END SUBROUTINE pixel\_search\_for\_neighbors
\EndProcedure
\end{algorithmic}
\end{algorithm}
